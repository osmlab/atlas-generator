plugins {
    id 'java'
    id 'maven-publish'
    id 'idea'
    id 'signing'
    id 'checkstyle'
    id 'jacoco'
    id 'java-library'
    id "com.diffplug.spotless" version "6.1.0"
    id 'org.sonarqube' version '3.3'
}

apply from: 'dependencies.gradle'
apply from: 'gradle/quality.gradle'
apply from: 'gradle/deployment.gradle'
apply from: 'gradle/execution.gradle'

description = "Atlas Generator Library"

sourceCompatibility=11
targetCompatibility=11

repositories
{
    // For geotools
    maven {
      url "https://repo.osgeo.org/repository/release/"
      content {
        // osgeo removed the jar and added a -norce version
        excludeVersion("log4j", "log4j", "1.2.17")
      }
    }
    mavenCentral()
}

configurations
{
    compile
    {
        resolutionStrategy
        {
            force packages.atlas
            force packages.spark.core
            force packages.spark.sql
            // Snappy 1.1.1.6 is the one that has the proper .so libs.
            // https://github.com/xerial/snappy-java/issues/6
            force packages.snappy
        }
    }
    shaded {
        extendsFrom(implementation) 
        resolutionStrategy
        {
            force packages.atlas
            force packages.spark.core
            force packages.spark.sql
            // Snappy 1.1.1.6 is the one that has the proper .so libs.
            // https://github.com/xerial/snappy-java/issues/6
            force packages.snappy
        }
        // Hadoop and Spark are way too fat.
        exclude group: 'org.apache.hadoop'
        exclude group: 'org.apache.spark'
        exclude group: 'org.slf4j', module: 'slf4j-api'
    }
}

dependencies
{
    api packages.atlas
    api packages.spark.core
    api packages.spark.sql
    api packages.jline

    checkstyle packages.checkstyle
    checkstyle packages.atlas_checkstyle

    shaded project.configurations.getByName('compile')
}

task shaded(type: Jar){
    archiveBaseName = project.name
    classifier = 'shaded'
    from
    {
        configurations.shaded.collect
        {
            it.isDirectory() ? it : zipTree(it).matching{
                exclude
                {
                    it.path.contains('META-INF') && (it.path.endsWith('.SF') || it.path.endsWith('.DSA') || it.path.endsWith('.RSA'))
                }
            }
        }
    }
    with jar
    zip64 = true
}

task fat(type: Jar){
    archiveBaseName = project.name
    classifier = 'fat'
    from
    {
        configurations.compile.collect
        {
            it.isDirectory() ? it : zipTree(it).matching{
                exclude
                {
                    it.path.contains('META-INF') && (it.path.endsWith('.SF') || it.path.endsWith('.DSA') || it.path.endsWith('.RSA'))
                }
            }
        }
    }
    with jar
    zip64 = true
}

/**
 * Artifact related items
 */
task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts
{
    archives javadocJar, sourcesJar
}

/*
 * This is to skip the tasks for which there is a skip<TaskName>=true
 * environment variable
 */
def skippedTaskNames = System.getenv().findAll { key, value ->
    key.startsWith("skip") && value.equalsIgnoreCase("true")
}.keySet().collect { it.substring(4) }
gradle.startParameter.excludedTaskNames += skippedTaskNames

idea {
    project {
        languageLevel = '11'
    }
}

tasks.each {
  task -> if (task.hasProperty("duplicatesStrategy")) {
    task.setProperty("duplicatesStrategy", "EXCLUDE")
  }
}
